<?xml version="1.0" encoding="UTF-8"?>
<proposal href="proposals/ANGLE_timer_query/">
  <name>ANGLE_timer_query</name>

  <contact> <a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL
  working group</a> (public_webgl 'at' khronos.org) </contact>

  <contributors>
    <contributor>Contributors to ARB_occlusion_query</contributor>
    <contributor>Contributors to EXT_timer_query</contributor>
    <contributor>Contributors to ARB_timer_query</contributor>
    <contributor>Ben Vanik, Google Inc.</contributor>
    <contributor>Daniel Koch, TransGaming Inc.</contributor>
    <contributor>Members of the WebGL working group</contributor>
  </contributors>

  <number>NN</number>

  <depends>
    <api version="1.0"/>
  </depends>

  <overview>
    <mirrors href="https://angleproject.googlecode.com/svn/trunk/extensions/ANGLE_timer_query.txt"
             name="ANGLE_timer_query">
      <addendum>
        Uses callbacks to provide the query's result, or indicate if the query was invalidated.
      </addendum>
    </mirrors>

    <features>
      <feature>
        Allows applications and tools to accurately determine the time it takes to fully complete a
        set of OpenGL commands, without stalling the rendering pipeline.
      </feature>
    </features>
  </overview>

  <idl xml:space="preserve">
    typedef unsigned long long GLuint64ANGLE;

    [NoInterfaceObject]
    interface WebGLQueryEvent {
      GLenum resultType;
      GLuint64ANGLE result;
    };

    [TreatNonCallableAsNull]
    callback QueryEventHandlerNonNull = any (WebGLQueryEvent event);
    typedef QueryEventHandlerNonNull? QueryEventHandler;

    [NoInterfaceObject]
    interface WebGLTimerQueryANGLE : WebGLObject {
    };

    interface ANGLE_timer_query {
      const GLenum QUERY_COUNTER_BITS_ANGLE      = 0x8864;
      const GLenum CURRENT_QUERY_ANGLE           = 0x8865;
      const GLenum TIME_ELAPSED_ANGLE            = 0x88BF;
      const GLenum TIMESTAMP_ANGLE               = 0x8E28;
      const GLenum INVALIDATED_ANGLE             = 0x????;

      WebGLTimerQueryANGLE? createQueryANGLE();
      void deleteQueryANGLE(WebGLTimerQueryANGLE? query);
      [WebGLHandlesContextLoss] boolean isQueryANGLE(WebGLTimerQueryANGLE? query);
      void beginQueryANGLE(enum target, WebGLTimerQueryANGLE? query, QueryEventHandler callback);
      void endQueryANGLE(enum target);
      void queryCounterANGLE(WebGLTimerQueryANGLE? query, enum target, QueryEventHandler callback);
      void cancelQueryANGLE(WebGLTimerQueryANGLE? query);
      any getQueryANGLE(enum target, enum pname);
    };
  </idl>

  <newfun>
    <function name="createQueryAngle" type="WebGLTimerQueryANGLE?">
    </function>
  </newfun>

  <newfun>
    <function name="deleteQueryAngle" type="void">
      <param name="query" type="WebGLTimerQueryANGLE?"/>
    </function>
  </newfun>

  <newfun>
    <function name="isQueryANGLE" type="boolean">
      <param name="query" type="WebGLTimerQueryANGLE?"/>
      Returns true if the passed WebGLTimerQueryANGLE is valid and false otherwise. Returns false if
      the query's <a
      href="http://www.khronos.org/registry/webgl/specs/1.0.1/#webgl-object-invalidated-flag">invalidated
      flag</a> is set.
    </function>
  </newfun>

  <newfun>
    <function name="beginQueryANGLE" type="void">
      <param name="target" type="GLenum"/>
      <param name="query" type="WebGLTimerQueryANGLE?"/>
      <param name="callback" type="QueryEventHandler"/>

      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code>.
      </p>

      <p>
      Initiates the type of query specified by <code>target</code>.
      </p>

      <p>
      If the query is issued and processed, and not cancelled via <code>cancelQueryANGLE</code>,
      then <code>callback</code> will be called with <em>callback this value</em> set to the
      <code>WebGLTimerQueryANGLE</code> object, and <code>event</code> argument configured as
      follows:

      <ul>
        <li> If the query is processed successfully:
          <ul>
            <li> <code>resultType</code> set to <code>TIME_ELAPSED_ANGLE</code> </li>
            <li> <code>result</code> set to the query's elapsed time </li>
          </ul>
        </li>
        <li> If the query is invalidated after issue (for as yet unspecified reasons):
          <ul>
            <li> <code>resultType</code> set to <code>TIME_ELAPSED_ANGLE</code> </li>
            <li> <code>result</code> set to the query's elapsed time </li>
          </ul>
        </li>
      </ul>
      </p>

      <p>
      If the query is cancelled via <code>cancelQueryANGLE</code>, then the callback will not be
      called for this query object, even if it completes successfully.
      </p>

      <p>
      If <code>query</code> or <code>callback</code> are null, generates an INVALID_OPERATION error.
      </p>
    </function>
  </newfun>

  <newfun>
    <function name="endQueryANGLE" type="void">
      <param name="target" type="GLenum"/>
      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code>.
      </p>

      <p>
      Ends the active query. All error conditions specified in ANGLE_timer_query apply.
      </p>

      <p>
      At an unspecified time after the GL processes the EndQuery command, and if
      <code>cancelQueryANGLE</code> has not been called, the WebGL implementation will fire a
      WebGLQueryEvent at the <code>WebGLTimerQueryANGLE</code> object. See
      <code>beginQueryANGLE</code> for the description of arguments to the associated callback.
      </p>
    </function>
  </newfun>

  <newfun>
    <function name="queryCounterANGLE" type="void">
      <param name="query" type="WebGLTimerQueryANGLE?"/>
      <param name="target" type="GLenum"/>
      <param name="callback" type="QueryEventHandler"/>
      <code>target</code> accepts <code>TIMESTAMP_ANGLE</code>.

      <p>
      Issues the type of query specified by <code>target</code>.
      </p>

      <p>
      At an unspecified time after the GL processes the QueryCounter command, <code>callback</code>
      will be called with <code>this</code> argument the <code>WebGLTimerQueryANGLE</code> object,
      and <code>event</code> argument configured as follows:

      <ul>
        <li> <code>resultType</code> set to <code>TIMESTAMP_ANGLE</code> </li>
        <li> <code>result</code> set to the GL's timestamp when the query was processed </li>
      </ul>
      </p>

      <p>
      If the query is invalidated after issue (for as yet unspecified reasons),
      <code>callback</code> will be called with <em>callback this value</em> set to the
      <code>WebGLTimerQueryANGLE</code> object, and <code>event</code> argument set to a
      <code>WebGLQueryEvent</code> object configured as follows:
      <ul>
        <li> <code>resultType</code> set to <code>INVALIDATED_ANGLE</code> </li>
        <li> <code>result</code> set to 0 </li>
      </ul>
      </p>

      <p>
      If the query is cancelled via <code>cancelQueryANGLE</code>, then the callback will not be
      called for this query object, even if it completes successfully.
      </p>

      <p>
      If <code>query</code> or <code>callback</code> are null, generates an INVALID_OPERATION error.
      </p>
    </function>
  </newfun>

  <newfun>
    <function name="getQueryANGLE" type="any">
      <param name="target" type="GLenum"/>
      <param name="pname" type="GLenum"/>
      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code> or <code>TIMESTAMP_ANGLE</code>.
      </p>
      <p>
      <code>pname</code> accepts <code>CURRENT_QUERY_ANGLE</code> or <code>QUERY_COUNTER_BITS_ANGLE</code>.
      </p>
      <p>
      The return type of this method depends on the parameter queried:
      <table width="30%">
      <tr><th>pname</th><th>returned type</th></tr>
      <tr><td>CURRENT_QUERY_ANGLE</td><td>WebGLTimerQueryANGLE?</td></tr>
      <tr><td>QUERY_COUNTER_BITS_ANGLE</td><td>GLint</td></tr>
      </table>      
      </p>
    </function>
  </newfun>

  <newfun>
    <function name="cancelQueryANGLE" type="void">
      <param name="query" type="WebGLTimerQuery?"/>

      <p>
      Cancels the callback associated with <code>query</code>.
      </p>

      <p>
      If <code>query</code> is null, generates an INVALID_OPERATION error.
      </p>

      <p>
      If <code>query</code> has not been issued via <code>beginQueryANGLE</code> or
      <code>queryCounterANGLE</code>, generates an INVALID_OPERATION error.
      </p>

      <p>
      If the callback associated with <code>query</code> has already been called, generates an
      INVALID_OPERATION error.
      </p>
    </function>
  </newfun>

  <issues>
    <ol>
      <li>
        <p>
          Can getQueryParameterANGLE be exposed in its current form according to ECMAScript
          semantics?  ECMAScript's <a
          href="http://wiki.ecmascript.org/doku.php?id=strawman:concurrency">de-facto concurrency
          model</a> is "shared nothing" communicating event loops. Is it acceptable for sequential
          calls to getQueryParameterANGLE to return different answers? Note that Date.now() advances
          during script execution, so this may be fine; but if concerns are raised, then the API may
          need to be redesigned to use callbacks.
        </p>

        <p>
        <b>RESOLVED:</b> the API has been rewritten in terms of callbacks, so that polling for
        events' results is no longer possible.
        </p>
      </li>
    </ol>
  </issues>

  <samplecode xml:space="preserve">
    <pre>
        // Example (1) -- uses beginQueryANGLE/endQueryANGLE.
        var ext = gl.getExtension('ANGLE_timer_query');
        var query = ext.createQueryANGLE();
        ext.beginQueryANGLE(ext.TIME_ELAPSED_ANGLE, query, queryReady);

        // Draw object
        gl.drawElements(...);

        ext.endQueryANGLE(ext.TIME_ELAPSED_ANGLE);

        // At some point in the future, after returning control to the browser:
        function queryReady(event) {
          if (event.resultType == ext.TIME_ELAPSED_ANGLE) {
            // Do something useful with the time.  Note that care should be
            // taken to use all significant bits of the result, not just the
            // least significant 32 bits.
            adjustObjectLODBasedOnDrawTime(event.result);
          }
        }


        //----------------------------------------------------------------------

        // Example (2) -- same as the example above, but uses queryCounterANGLE instead.
        var ext = gl.getExtension('ANGLE_timer_query');
        var startQuery = ext.createQueryANGLE();
        var endQuery = ext.createQueryANGLE();
        var startQueryResult = 0;
        ext.queryCounterANGLE(startQuery, ext.TIMESTAMP_ANGLE, recordResult);

        // Draw object
        gl.drawElements(...);

        ext.queryCounterANGLE(endQuery, ext.TIMESTAMP_ANGLE, compareResults);

        function recordResult(event) {
          if (event.resultType == ext.TIMESTAMP_ANGLE) {
            startQueryResult = event.result;
          }
        }

        // At some point in the future, after returning control to the browser:
        function compareResults(event) {
          if (event.resultType == ext.TIMESTAMP_ANGLE &amp;&amp; startQueryResult != 0) {
            // Do something useful with the time.  Note that care should be
            // taken to use all significant bits of the result, not just the
            // least significant 32 bits.
            adjustObjectLODBasedOnDrawTime(event.result - startQueryResult);
          }
        }
    </pre>
  </samplecode>

  <history>
    <revision date="2013/04/02">
      <change>Initial revision.</change>
    </revision>
    <revision date="2013/04/03">
      <change>Based on public_webgl discussion, specified that queries' results only become available at well-defined times.</change>
    </revision>
    <revision date="2013/04/11">
      <change>Rewrote API in terms of callbacks.</change>
    </revision>
  </history>
</proposal>
