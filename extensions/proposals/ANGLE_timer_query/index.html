<!DOCTYPE html>
<!--AUTOGENERATED FILE - DO NOT EDIT - SEE Makefile-->
<html lang="en" xml:lang="en" xmlns="http://www.w3.org/1999/xhtml"><head><meta charset="UTF-8"/><title>WebGL ANGLE_timer_query Extension Proposed Specification</title><link rel="alternate" type="text/xml" href="extension.xml"/><link rel="stylesheet" type="text/css" href="../../../resources/Khronos-Proposal.css"/></head><body><!--begin-logo--><div class="left"><a href="http://webgl.org/"><img alt="WebGL" height="72" src="../../../resources/WebGL-Logo.png" width="156"/></a></div><div class="right"><a href="http://khronos.org/"><img alt="Khronos" height="60" src="../../../resources/KhronosGroup-3D.png" width="220"/></a></div><div style="clear: both;">Â </div><br/><!--end-logo--><h1>WebGL ANGLE_timer_query Extension Proposed Specification</h1><p><strong>DO NOT IMPLEMENT!!!</strong></p><h2 class="no-toc">Name</h2><p>ANGLE_timer_query</p><h2 class="no-toc">Contact</h2><p> <a href="https://www.khronos.org/webgl/public-mailing-list/">WebGL
  working group</a> (public_webgl 'at' khronos.org) </p><h2 class="no-toc">Contributors</h2><p>Contributors to ARB_occlusion_query</p><p>Contributors to EXT_timer_query</p><p>Contributors to ARB_timer_query</p><p>Ben Vanik, Google Inc.</p><p>Daniel Koch, TransGaming Inc.</p><p>Members of the WebGL working group</p><h2 class="no-toc">Version</h2><p> Last modified date: April 11, 2013<br/>
          Revision: 3</p><h2 class="no-toc">Number</h2><p> WebGL extension #NN</p><h2 class="no-toc">Dependencies</h2>
    <p> Written against the <a href="http://www.khronos.org/registry/webgl/specs/1.0/">WebGL API 1.0</a> specification. </p>
  <h2 class="no-toc">Overview</h2>
    <p> This extension exposes the
  <a href="https://angleproject.googlecode.com/svn/trunk/extensions/ANGLE_timer_query.txt">ANGLE_timer_query</a> functionality to WebGL.
  </p><p>The following WebGL-specific behavioral changes apply:</p><ul><li>
        Uses callbacks to provide the query's result, or indicate if the query was invalidated.
      </li></ul><p>
        Consult the above extension for documentation, issues and new functions and enumerants.
      </p>

    <p> When this extension is enabled: </p><ul><li>
        Allows applications and tools to accurately determine the time it takes to fully complete a
        set of OpenGL commands, without stalling the rendering pipeline.
      </li></ul>
  <h2 class="no-toc">IDL</h2><pre class="idl">
    typedef unsigned long long GLuint64ANGLE;

    [NoInterfaceObject]
    interface WebGLQueryEvent {
      GLenum resultType;
      GLuint64ANGLE result;
    };

    [TreatNonCallableAsNull]
    callback QueryEventHandlerNonNull = any (WebGLQueryEvent event);
    typedef QueryEventHandlerNonNull? QueryEventHandler;

    [NoInterfaceObject]
    interface WebGLTimerQueryANGLE : WebGLObject {
    };

    interface ANGLE_timer_query {
      const GLenum QUERY_COUNTER_BITS_ANGLE      = 0x8864;
      const GLenum CURRENT_QUERY_ANGLE           = 0x8865;
      const GLenum TIME_ELAPSED_ANGLE            = 0x88BF;
      const GLenum TIMESTAMP_ANGLE               = 0x8E28;
      const GLenum INVALIDATED_ANGLE             = 0x????;

      WebGLTimerQueryANGLE? createQueryANGLE();
      void deleteQueryANGLE(WebGLTimerQueryANGLE? query);
      [WebGLHandlesContextLoss] boolean isQueryANGLE(WebGLTimerQueryANGLE? query);
      void beginQueryANGLE(enum target, WebGLTimerQueryANGLE? query, QueryEventHandler callback);
      void endQueryANGLE(enum target);
      void queryCounterANGLE(WebGLTimerQueryANGLE? query, enum target, QueryEventHandler callback);
      void cancelQueryANGLE(WebGLTimerQueryANGLE? query);
      any getQueryANGLE(enum target, enum pname);
    };
  </pre><h2 class="no-toc">New Functions</h2><dl class="methods"><dt class="idl-code">WebGLTimerQueryANGLE? createQueryAngle()</dt><dd>
    </dd></dl><dl class="methods"><dt class="idl-code">void deleteQueryAngle(WebGLTimerQueryANGLE? query)</dt><dd>
      
    </dd></dl><dl class="methods"><dt class="idl-code">boolean isQueryANGLE(WebGLTimerQueryANGLE? query)</dt><dd>
      
      Returns true if the passed WebGLTimerQueryANGLE is valid and false otherwise. Returns false if
      the query's <a href="http://www.khronos.org/registry/webgl/specs/1.0.1/#webgl-object-invalidated-flag">invalidated
      flag</a> is set.
    </dd></dl><dl class="methods"><dt class="idl-code">void beginQueryANGLE(GLenum target, WebGLTimerQueryANGLE? query, QueryEventHandler callback)</dt><dd>
      
      
      

      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code>.
      </p>

      <p>
      Initiates the type of query specified by <code>target</code>.
      </p>

      <p>
      If the query is issued and processed, and not cancelled via <code>cancelQueryANGLE</code>,
      then <code>callback</code> will be called with <em>callback this value</em> set to the
      <code>WebGLTimerQueryANGLE</code> object, and <code>event</code> argument configured as
      follows:

      <ul>
        <li> If the query is processed successfully:
          <ul>
            <li> <code>resultType</code> set to <code>TIME_ELAPSED_ANGLE</code> </li>
            <li> <code>result</code> set to the query's elapsed time </li>
          </ul>
        </li>
        <li> If the query is invalidated after issue (for as yet unspecified reasons):
          <ul>
            <li> <code>resultType</code> set to <code>TIME_ELAPSED_ANGLE</code> </li>
            <li> <code>result</code> set to the query's elapsed time </li>
          </ul>
        </li>
      </ul>
      </p>

      <p>
      If the query is cancelled via <code>cancelQueryANGLE</code>, then the callback will not be
      called for this query object, even if it completes successfully.
      </p>

      <p>
      If <code>query</code> or <code>callback</code> are null, generates an INVALID_OPERATION error.
      </p>
    </dd></dl><dl class="methods"><dt class="idl-code">void endQueryANGLE(GLenum target)</dt><dd>
      
      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code>.
      </p>

      <p>
      Ends the active query. All error conditions specified in ANGLE_timer_query apply.
      </p>

      <p>
      At an unspecified time after the GL processes the EndQuery command, and if
      <code>cancelQueryANGLE</code> has not been called, the WebGL implementation will fire a
      WebGLQueryEvent at the <code>WebGLTimerQueryANGLE</code> object. See
      <code>beginQueryANGLE</code> for the description of arguments to the associated callback.
      </p>
    </dd></dl><dl class="methods"><dt class="idl-code">void queryCounterANGLE(WebGLTimerQueryANGLE? query, GLenum target, QueryEventHandler callback)</dt><dd>
      
      
      
      <code>target</code> accepts <code>TIMESTAMP_ANGLE</code>.

      <p>
      Issues the type of query specified by <code>target</code>.
      </p>

      <p>
      At an unspecified time after the GL processes the QueryCounter command, <code>callback</code>
      will be called with <code>this</code> argument the <code>WebGLTimerQueryANGLE</code> object,
      and <code>event</code> argument configured as follows:

      <ul>
        <li> <code>resultType</code> set to <code>TIMESTAMP_ANGLE</code> </li>
        <li> <code>result</code> set to the GL's timestamp when the query was processed </li>
      </ul>
      </p>

      <p>
      If the query is invalidated after issue (for as yet unspecified reasons),
      <code>callback</code> will be called with <em>callback this value</em> set to the
      <code>WebGLTimerQueryANGLE</code> object, and <code>event</code> argument set to a
      <code>WebGLQueryEvent</code> object configured as follows:
      <ul>
        <li> <code>resultType</code> set to <code>INVALIDATED_ANGLE</code> </li>
        <li> <code>result</code> set to 0 </li>
      </ul>
      </p>

      <p>
      If the query is cancelled via <code>cancelQueryANGLE</code>, then the callback will not be
      called for this query object, even if it completes successfully.
      </p>

      <p>
      If <code>query</code> or <code>callback</code> are null, generates an INVALID_OPERATION error.
      </p>
    </dd></dl><dl class="methods"><dt class="idl-code">any getQueryANGLE(GLenum target, GLenum pname)</dt><dd>
      
      
      <p>
      <code>target</code> accepts <code>TIME_ELAPSED_ANGLE</code> or <code>TIMESTAMP_ANGLE</code>.
      </p>
      <p>
      <code>pname</code> accepts <code>CURRENT_QUERY_ANGLE</code> or <code>QUERY_COUNTER_BITS_ANGLE</code>.
      </p>
      <p>
      The return type of this method depends on the parameter queried:
      <table width="30%">
      <tr><th>pname</th><th>returned type</th></tr>
      <tr><td>CURRENT_QUERY_ANGLE</td><td>WebGLTimerQueryANGLE?</td></tr>
      <tr><td>QUERY_COUNTER_BITS_ANGLE</td><td>GLint</td></tr>
      </table>      
      </p>
    </dd></dl><dl class="methods"><dt class="idl-code">void cancelQueryANGLE(WebGLTimerQuery? query)</dt><dd>
      

      <p>
      Cancels the callback associated with <code>query</code>.
      </p>

      <p>
      If <code>query</code> is null, generates an INVALID_OPERATION error.
      </p>

      <p>
      If <code>query</code> has not been issued via <code>beginQueryANGLE</code> or
      <code>queryCounterANGLE</code>, generates an INVALID_OPERATION error.
      </p>

      <p>
      If the callback associated with <code>query</code> has already been called, generates an
      INVALID_OPERATION error.
      </p>
    </dd></dl><h2 class="no-toc">Sample Code</h2>
    <pre>
        // Example (1) -- uses beginQueryANGLE/endQueryANGLE.
        var ext = gl.getExtension('ANGLE_timer_query');
        var query = ext.createQueryANGLE();
        ext.beginQueryANGLE(ext.TIME_ELAPSED_ANGLE, query, queryReady);

        // Draw object
        gl.drawElements(...);

        ext.endQueryANGLE(ext.TIME_ELAPSED_ANGLE);

        // At some point in the future, after returning control to the browser:
        function queryReady(event) {
          if (event.resultType == ext.TIME_ELAPSED_ANGLE) {
            // Do something useful with the time.  Note that care should be
            // taken to use all significant bits of the result, not just the
            // least significant 32 bits.
            adjustObjectLODBasedOnDrawTime(event.result);
          }
        }


        //----------------------------------------------------------------------

        // Example (2) -- same as the example above, but uses queryCounterANGLE instead.
        var ext = gl.getExtension('ANGLE_timer_query');
        var startQuery = ext.createQueryANGLE();
        var endQuery = ext.createQueryANGLE();
        var startQueryResult = 0;
        ext.queryCounterANGLE(startQuery, ext.TIMESTAMP_ANGLE, recordResult);

        // Draw object
        gl.drawElements(...);

        ext.queryCounterANGLE(endQuery, ext.TIMESTAMP_ANGLE, compareResults);

        function recordResult(event) {
          if (event.resultType == ext.TIMESTAMP_ANGLE) {
            startQueryResult = event.result;
          }
        }

        // At some point in the future, after returning control to the browser:
        function compareResults(event) {
          if (event.resultType == ext.TIMESTAMP_ANGLE &amp;&amp; startQueryResult != 0) {
            // Do something useful with the time.  Note that care should be
            // taken to use all significant bits of the result, not just the
            // least significant 32 bits.
            adjustObjectLODBasedOnDrawTime(event.result - startQueryResult);
          }
        }
    </pre>
  <h2 class="no-toc">Issues</h2>
    <ol>
      <li>
        <p>
          Can getQueryParameterANGLE be exposed in its current form according to ECMAScript
          semantics?  ECMAScript's <a href="http://wiki.ecmascript.org/doku.php?id=strawman:concurrency">de-facto concurrency
          model</a> is "shared nothing" communicating event loops. Is it acceptable for sequential
          calls to getQueryParameterANGLE to return different answers? Note that Date.now() advances
          during script execution, so this may be fine; but if concerns are raised, then the API may
          need to be redesigned to use callbacks.
        </p>

        <p>
        <b>RESOLVED:</b> the API has been rewritten in terms of callbacks, so that polling for
        events' results is no longer possible.
        </p>
      </li>
    </ol>
  <h2 class="no-toc">Revision History</h2><p>Revision 1, 2013/04/02</p><ul><li>Initial revision.</li></ul><p>Revision 2, 2013/04/03</p><ul><li>Based on public_webgl discussion, specified that queries' results only become available at well-defined times.</li></ul><p>Revision 3, 2013/04/11</p><ul><li>Rewrote API in terms of callbacks.</li></ul></body></html>
